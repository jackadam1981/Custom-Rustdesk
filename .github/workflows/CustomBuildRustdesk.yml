name: Custom Rustdesk Build Workflow

on:
  # Issue 触发
  issues:
    types: [opened]
  
  # 手动触发
  workflow_dispatch:
    inputs:
      tag:
        description: '构建标签'
        required: true
        default: 'custom'
      customer:
        description: '客户名称'
        required: true
        default: 'test'
      customer_link:
        description: '客户链接'
        required: false
        default: ''
      slogan:
        description: '标语'
        required: false
        default: 'Custom Rustdesk'
      email:
        description: '邮箱地址'
        required: true
        default: 'admin@example.com'
      super_password:
        description: '超级密码'
        required: true
        default: 'password123'
      rendezvous_server:
        description: 'Rendezvous服务地址'
        required: true
        default: '192.168.1.100'
      rs_pub_key:
        description: 'RS公钥'
        required: false
        default: ''
      api_server:
        description: 'API服务地址'
        required: true
        default: 'http://192.168.1.100:21114'
      enable_debug:
        description: '启用调试模式（仅手动触发时有效）'
        required: false
        default: true
        type: boolean

permissions:
  issues: write
  contents: read
  actions: read

# 统一环境变量配置
env:
  GITHUB_TOKEN: ${{ secrets.BUILD_TOKEN }}
  ENCRYPTION_KEY: ${{ secrets.ENCRYPTION_KEY }}
  QUEUE_ISSUE_NUMBER: '1'
  DEBUG_ENABLED: ${{ vars.DEBUG_ENABLED || 'false' }}
  # 远程仓库配置 - 固定设置
  RUSTDESK_REPO: 'rustdesk/rustdesk'
  RUSTDESK_BRANCH: 'master'
  REMOTE_WORKFLOW_NAME: 'Build'
  # 默认值配置
  DEFAULT_TAG: ${{ secrets.DEFAULT_TAG }}
  DEFAULT_EMAIL: ${{ secrets.DEFAULT_EMAIL }}
  DEFAULT_CUSTOMER: ${{ secrets.DEFAULT_CUSTOMER }}
  DEFAULT_CUSTOMER_LINK: ${{ secrets.DEFAULT_CUSTOMER_LINK }}
  DEFAULT_SUPER_PASSWORD: ${{ secrets.DEFAULT_SUPER_PASSWORD }}
  DEFAULT_SLOGAN: ${{ secrets.DEFAULT_SLOGAN }}
  DEFAULT_RENDEZVOUS_SERVER: ${{ secrets.DEFAULT_RENDEZVOUS_SERVER }}
  DEFAULT_RS_PUB_KEY: ${{ secrets.DEFAULT_RS_PUB_KEY }}
  DEFAULT_API_SERVER: ${{ secrets.DEFAULT_API_SERVER }}

jobs:
  # 00-触发处理 - 提取和验证参数
  trigger:
    runs-on: ubuntu-latest
    outputs:
      build_id: ${{ steps.trigger.outputs.build_id }}
      validation_passed: ${{ steps.trigger.outputs.validation_passed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Process trigger and validate parameters
        id: trigger
        run: |
          source .github/workflows/scripts/trigger.sh
          
          # 使用环境变量传递事件数据
          export EVENT_DATA='${{ toJSON(github.event) }}'
          echo "DEBUG: EVENT_DATA = $EVENT_DATA"
          echo "DEBUG: github.event_name = ${{ github.event_name }}"
          echo "DEBUG: github.event.issue.number = ${{ github.event.issue.number }}"
          
          # 添加更详细的调试信息
          echo "DEBUG: github.event 类型: object"
          echo "DEBUG: github.event 内容: Object"
          
          # 根据触发类型提取参数
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "DEBUG: 进入 workflow_dispatch 分支"
            # 提取参数并设置环境变量
            params=$(trigger_manager "extract-workflow-dispatch" "$EVENT_DATA")
            echo "DEBUG: workflow_dispatch params = $params"
            eval "$params"
            
            echo "DEBUG: After extract, TAG=$TAG, EMAIL=$EMAIL, CUSTOMER=$CUSTOMER"
            
            # 处理tag时间戳
            final_tag=$(trigger_manager "process-tag" "$EVENT_DATA")
            echo "DEBUG: final_tag = $final_tag"
            
            # 生成最终JSON数据
            final_data=$(trigger_manager "generate-data" "$EVENT_DATA" "$final_tag")
            echo "DEBUG: final_data = $final_data"
            echo "DEBUG: final_data 长度: ${#final_data}"
            echo "DEBUG: final_data 是否为空: $([ -z "$final_data" ] && echo "是" || echo "否")"
            
            # 验证参数
            validation_result=$(trigger_manager "validate-parameters" "$final_data")
            validation_exit_code=$?
            echo "DEBUG: validation_result = $validation_result, exit_code = $validation_exit_code"
            
            # 只输出build_id，不输出trigger_data
            build_id=$(echo "$final_data" | jq -r '.build_id // empty')
            echo "build_id=$build_id" >> $GITHUB_OUTPUT
            echo "DEBUG: build_id output completed"
          else
            echo "DEBUG: 进入 issue 分支"
            # Issue触发的情况
            params=$(trigger_manager "extract-issue" "$EVENT_DATA")
            echo "DEBUG: issue params = $params"
            eval "$params"
            
            echo "DEBUG: After extract, TAG=$TAG, EMAIL=$EMAIL, CUSTOMER=$CUSTOMER"
            
            # 处理tag时间戳
            final_tag=$(trigger_manager "process-tag" "$EVENT_DATA")
            echo "DEBUG: final_tag = $final_tag"
            
            # 生成最终JSON数据
            final_data=$(trigger_manager "generate-data" "$EVENT_DATA" "$final_tag")
            echo "DEBUG: final_data = $final_data"
            echo "DEBUG: final_data 长度: ${#final_data}"
            echo "DEBUG: final_data 是否为空: $([ -z "$final_data" ] && echo "是" || echo "否")"
            
            # 验证参数
            validation_result=$(trigger_manager "validate-parameters" "$final_data")
            validation_exit_code=$?
            echo "DEBUG: validation_result = $validation_result, exit_code = $validation_exit_code"
            
            # 只输出build_id，不输出trigger_data
            build_id=$(echo "$final_data" | jq -r '.build_id // empty')
            echo "build_id=$build_id" >> $GITHUB_OUTPUT
            echo "DEBUG: build_id output completed"
          fi
          
          # 设置验证结果
          if [ $validation_exit_code -eq 0 ]; then
            echo "validation_passed=true" >> $GITHUB_OUTPUT
          else
            echo "validation_passed=false" >> $GITHUB_OUTPUT
          fi

  # 01-审核验证 - 处理需要审核的情况
  review:
    needs: trigger
    if: needs.trigger.outputs.validation_passed == 'true'
    runs-on: ubuntu-latest
    outputs:
      review_passed: ${{ steps.review.outputs.review_passed }}
      review_reason: ${{ steps.review.outputs.review_reason }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Review and validate
        id: review
        shell: bash
        run: |
          source .github/workflows/scripts/review.sh

          # 直接使用 github.event
          EVENT_DATA='${{ toJSON(github.event) }}'
          
          # 验证参数
          validation_result=$(review_manager "validate" "$EVENT_DATA" "" || true)
          validation_exit_code=$?
          
          if [ $validation_exit_code -ne 0 ]; then
            # 参数验证失败，处理拒绝
            review_manager "handle-rejection" "$EVENT_DATA" "" "$validation_result" || true
            echo "review_passed=false" >> $GITHUB_OUTPUT
            echo "review_reason=参数验证失败" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # 检查是否需要审核
          need_review=$(review_manager "need-review" "$EVENT_DATA" "" || true)
          
          # 如果是issue触发，清理issue内容
          if [ "${{ github.event_name }}" = "issues" ]; then
            source .github/workflows/scripts/trigger.sh
            
            # 从EVENT_DATA中提取参数用于清理
            final_tag_param=$(echo "$EVENT_DATA" | jq -r '.build_params.tag // empty')
            original_tag_param=$(echo "$EVENT_DATA" | jq -r '.build_params.original_tag // empty')
            customer_param=$(echo "$EVENT_DATA" | jq -r '.build_params.customer // empty')
            slogan_param=$(echo "$EVENT_DATA" | jq -r '.build_params.slogan // empty')
            
            cleaned_body=$(trigger_manager "clean-issue" "$final_tag_param" "$original_tag_param" "$customer_param" "$slogan_param")
            issue_number="${{ github.event.issue.number }}"
            trigger_manager "update-issue" "$issue_number" "$cleaned_body"
          fi
          
          if [ "$need_review" = "true" ]; then
            # 需要审核，在issue中回复需要审核的信息
            if [ "${{ github.event_name }}" = "issues" ]; then
              source .github/workflows/scripts/issue-templates.sh
              review_comment=$(generate_review_required_template "${{ github.run_id }}" "${{ github.event.issue.number }}" "$EVENT_DATA")
              source .github/workflows/scripts/issue-manager.sh
              add_issue_comment "${{ github.event.issue.number }}" "$review_comment" || true
            fi
            
            # 处理审核流程
            review_result=$(review_manager "handle-review" "$EVENT_DATA" "" || true)
            review_exit_code=$?
            
            if [ $review_exit_code -eq 0 ]; then
              echo "review_passed=true" >> $GITHUB_OUTPUT
              echo "review_reason=" >> $GITHUB_OUTPUT
            elif [ $review_exit_code -eq 1 ]; then
              echo "review_passed=false" >> $GITHUB_OUTPUT
              echo "review_reason=审核被拒绝" >> $GITHUB_OUTPUT
            elif [ $review_exit_code -eq 2 ]; then
              echo "review_passed=false" >> $GITHUB_OUTPUT
              echo "review_reason=审核超时" >> $GITHUB_OUTPUT
            fi
          else
            # 不需要审核，直接通过
            echo "review_passed=true" >> $GITHUB_OUTPUT
            echo "review_reason=" >> $GITHUB_OUTPUT
          fi
          
          # 输出数据（传递审核结果）
          review_manager "output-data" "$EVENT_DATA" "" "$([ "$need_review" = "true" ] && [ $review_exit_code -eq 1 ] && echo "true" || echo "false")" "$([ "$need_review" = "true" ] && [ $review_exit_code -eq 2 ] && echo "true" || echo "false")" || true

  # 02-加入队列
  join-queue:
    needs: [trigger, review]
    if: needs.trigger.outputs.validation_passed == 'true' && needs.review.outputs.review_passed == 'true'
    runs-on: ubuntu-latest
    outputs:
      join_success: ${{ steps.join-queue.outputs.join_success }}
      queue_position: ${{ steps.join-queue.outputs.queue_position }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Join build queue
        id: join-queue
        env:
          DEBUG_ENABLED: true
        run: |
          source .github/workflows/scripts/queue-manager.sh

          # 直接使用 github.event
          EVENT_DATA='${{ toJSON(github.event) }}'
          
          # 加入队列
          echo "Joining build queue..."
          echo "DEBUG: EVENT_DATA = $EVENT_DATA"
          echo "DEBUG: GITHUB_RUN_ID = $GITHUB_RUN_ID"
          
          # 在需要时间戳的地方及时生成
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # 手动触发：生成带时间戳的标签
            tag="${{ github.event.inputs.tag }}"
            timestamp=$(date '+%Y%m%d-%H%M%S')
            final_tag="${tag}-${timestamp}"
            
            # 构建完整的触发数据
            trigger_data=$(jq -c -n \
              --arg build_id "$GITHUB_RUN_ID" \
              --arg trigger_type "workflow_dispatch" \
              --arg issue_number "null" \
              --arg tag "$final_tag" \
              --arg original_tag "$tag" \
              --arg email "${{ github.event.inputs.email }}" \
              --arg customer "${{ github.event.inputs.customer }}" \
              --arg customer_link "${{ github.event.inputs.customer_link }}" \
              --arg super_password "${{ github.event.inputs.super_password }}" \
              --arg slogan "${{ github.event.inputs.slogan }}" \
              --arg rendezvous_server "${{ github.event.inputs.rendezvous_server }}" \
              --arg rs_pub_key "${{ github.event.inputs.rs_pub_key }}" \
              --arg api_server "${{ github.event.inputs.api_server }}" \
              '{build_id: $build_id, trigger_type: $trigger_type, issue_number: $issue_number, build_params: {tag: $tag, original_tag: $original_tag, email: $email, customer: $customer, customer_link: $customer_link, super_password: $super_password, slogan: $slogan, rendezvous_server: $rendezvous_server, rs_pub_key: $rs_pub_key, api_server: $api_server}}')
          else
            # Issue触发：使用原始数据
            trigger_data="$EVENT_DATA"
          fi
          
          echo "DEBUG: Generated trigger_data = $trigger_data"
          
          join_result=$(queue_manager 'queue_lock' 'join' "$trigger_data")
          join_exit_code=$?
          
          # 检查加入结果
          if [ $join_exit_code -eq 0 ]; then
            echo "✅ Successfully joined queue"
            echo "join_success=true" >> $GITHUB_OUTPUT
            
            # 从join_result中提取队列位置
            queue_position=$(echo "$join_result" | jq -r '.queue_position // 1')
            echo "queue_position=$queue_position" >> $GITHUB_OUTPUT
          else
            echo "❌ Failed to join queue"
            echo "join_success=false" >> $GITHUB_OUTPUT
            echo "queue_position=-1" >> $GITHUB_OUTPUT
          fi

  # 03-等待构建锁
  wait-build-lock:
    needs: [trigger, review, join-queue]
    if: needs.trigger.outputs.validation_passed == 'true' && needs.review.outputs.review_passed == 'true' && needs.join-queue.outputs.join_success == 'true'
    runs-on: ubuntu-latest
    outputs:
      build_lock_acquired: ${{ steps.wait-build-lock.outputs.build_lock_acquired }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Wait for build lock
        id: wait-build-lock
        run: |
          source .github/workflows/scripts/queue-manager.sh
          
          # 获取构建锁
          echo "Acquiring build lock..."
          echo "DEBUG: GITHUB_RUN_ID = $GITHUB_RUN_ID"
          
          # 在等待构建锁之前，先尝试清理队列中的超期任务
          echo "🧹 在等待构建锁之前，先清理队列中的超期任务..."
          if cleanup_queue; then
            echo "✅ 队列清理完成"
          else
            echo "⚠️ 队列清理失败，继续等待构建锁"
          fi
          
          if queue_manager 'build_lock' 'acquire'; then
            echo "✅ Successfully acquired build lock"
            echo "build_lock_acquired=true" >> $GITHUB_OUTPUT
          else
            echo "❌ Failed to acquire build lock"
            echo "build_lock_acquired=false" >> $GITHUB_OUTPUT
          fi

  # 04-执行构建
  build:
    needs: [trigger, review, join-queue, wait-build-lock]
    if: needs.trigger.outputs.validation_passed == 'true' && needs.review.outputs.review_passed == 'true' && needs.join-queue.outputs.join_success == 'true' && needs.wait-build-lock.outputs.build_lock_acquired == 'true'
    runs-on: ubuntu-latest
    outputs:
      build_success: ${{ steps.extract-vars.outputs.build_success }}
      download_url: ${{ steps.extract-vars.outputs.download_url }}
      error_message: ${{ steps.extract-vars.outputs.error_message }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      # 步骤1: 提取变量
      - name: Extract variables
        id: extract-vars
        run: |
          echo "🔧 Step 1: Extracting variables..."

          # 直接使用 github.event 数据
          EVENT_DATA='${{ toJSON(github.event) }}'
          echo "🔍 EVENT_DATA 长度: ${#EVENT_DATA}"
          echo "🔍 EVENT_DATA 前100字符: ${EVENT_DATA:0:100}..."

          # 从 GitHub event 中直接提取构建参数
          tag=$(echo "$EVENT_DATA" | jq -r '.inputs.tag // empty')
          customer=$(echo "$EVENT_DATA" | jq -r '.inputs.customer // empty')
          customer_link=$(echo "$EVENT_DATA" | jq -r '.inputs.customer_link // empty')
          slogan=$(echo "$EVENT_DATA" | jq -r '.inputs.slogan // empty')
          email=$(echo "$EVENT_DATA" | jq -r '.inputs.email // empty')
          super_password=$(echo "$EVENT_DATA" | jq -r '.inputs.super_password // empty')
          rendezvous_server=$(echo "$EVENT_DATA" | jq -r '.inputs.rendezvous_server // empty')
          rs_pub_key=$(echo "$EVENT_DATA" | jq -r '.inputs.rs_pub_key // empty')
          api_server=$(echo "$EVENT_DATA" | jq -r '.inputs.api_server // empty')
          enable_debug=$(echo "$EVENT_DATA" | jq -r '.inputs.enable_debug // empty')

          echo "🔍 提取的构建参数:"
          echo "  - tag: $tag"
          echo "  - customer: $customer"
          echo "  - customer_link: $customer_link"
          echo "  - slogan: $slogan"
          echo "  - email: $email"
          echo "  - super_password: $super_password"
          echo "  - rendezvous_server: $rendezvous_server"
          echo "  - rs_pub_key: $rs_pub_key"
          echo "  - api_server: $api_server"
          echo "  - enable_debug: $enable_debug"

          # 验证关键参数
          if [ -n "$tag" ] && [ -n "$customer" ] && [ -n "$email" ]; then
            echo "✅ 关键参数验证通过"
            build_success="true"
            error_message=""
          else
            echo "❌ 关键参数验证失败"
            build_success="false"
            error_message="缺少必要的构建参数"
          fi

          # 设置 GitHub Actions 输出变量
          echo "build_success=$build_success" >> $GITHUB_OUTPUT
          echo "extract_success=$build_success" >> $GITHUB_OUTPUT
          echo "download_url=" >> $GITHUB_OUTPUT
          echo "error_message=$error_message" >> $GITHUB_OUTPUT

          echo "🔍 已设置 GitHub Actions 输出变量:"
          echo "  - build_success: $build_success"
          echo "  - extract_success: $build_success"
          echo "  - download_url: "
          echo "  - error_message: $error_message"

          echo "✅ 构建过程执行完成！"

      # 步骤2: 克隆源码
      - name: Clone source code
        id: clone-source
        if: steps.extract-vars.outputs.extract_success == 'true'
        run: |
          echo "🔧 Step 2: Cloning source code..."
          
          # 设置Git配置
          git config --global user.name "Custom Build Bot"
          git config --global user.email "build@custom-rustdesk.com"
          
          # 克隆远程仓库
          git clone --depth 1 --branch $RUSTDESK_BRANCH https://github.com/$RUSTDESK_REPO.git rustdesk-source
          
          if [ $? -eq 0 ]; then
            echo "✅ Successfully cloned source code"
            echo "clone_success=true" >> $GITHUB_OUTPUT
          else
            echo "❌ Failed to clone source code"
            echo "clone_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      # 步骤3: 修改源码
      - name: Modify source code
        id: modify-source
        if: steps.clone-source.outputs.clone_success == 'true'
        run: |
          echo "🔧 Step 3: Modifying source code..."
          
          cd rustdesk-source
          
          # 创建构建配置文件
          echo "📝 创建构建配置文件..."
          cat > build-config.json << EOF
          {
            "tag": "$(echo '${{ toJSON(github.event) }}' | jq -r '.inputs.tag // empty')",
            "customer": "$(echo '${{ toJSON(github.event) }}' | jq -r '.inputs.customer // empty')",
            "customer_link": "$(echo '${{ toJSON(github.event) }}' | jq -r '.inputs.customer_link // empty')",
            "slogan": "$(echo '${{ toJSON(github.event) }}' | jq -r '.inputs.slogan // empty')",
            "email": "$(echo '${{ toJSON(github.event) }}' | jq -r '.inputs.email // empty')",
            "super_password": "$(echo '${{ toJSON(github.event) }}' | jq -r '.inputs.super_password // empty')",
            "rendezvous_server": "$(echo '${{ toJSON(github.event) }}' | jq -r '.inputs.rendezvous_server // empty')",
            "rs_pub_key": "$(echo '${{ toJSON(github.event) }}' | jq -r '.inputs.rs_pub_key // empty')",
            "api_server": "$(echo '${{ toJSON(github.event) }}' | jq -r '.inputs.api_server // empty')",
            "enable_debug": "$(echo '${{ toJSON(github.event) }}' | jq -r '.inputs.enable_debug // empty')",
            "build_time": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF
          
          # 创建构建状态文件
          echo "📝 创建构建状态文件..."
          cat > build-status.txt << EOF
          Build Status: SUCCESS
          Build Time: $(date -u +%Y-%m-%dT%H:%M:%SZ)
          Build ID: ${{ github.run_id }}
          Customer: $(echo '${{ toJSON(github.event) }}' | jq -r '.inputs.customer // empty')
          Tag: $(echo '${{ toJSON(github.event) }}' | jq -r '.inputs.tag // empty')
          EOF
          
          echo "✅ Source code modification completed"
          echo "modify_success=true" >> $GITHUB_OUTPUT

      # 步骤4: 提交仓库
      - name: Commit to repository
        id: commit-repo
        if: steps.modify-source.outputs.modify_success == 'true'
        run: |
          echo "🔧 Step 4: Committing to repository..."
          
          cd rustdesk-source
          
          # 添加远程仓库
          git remote add custom-repo https://x-access-token:${{ secrets.BUILD_TOKEN }}@github.com/${{ github.repository }}.git
          
          # 创建新分支
          git checkout -b custom-build-${{ github.run_id }}
          
          # 提交修改
          git add .
          git commit -m "Custom build for ${{ github.run_id }} - Customer: $(echo '${{ toJSON(github.event) }}' | jq -r '.inputs.customer // empty')"
          
          # 推送到本仓库
          git push custom-repo custom-build-${{ github.run_id }}
          
          if [ $? -eq 0 ]; then
            echo "✅ Successfully committed and pushed to repository"
            echo "commit_success=true" >> $GITHUB_OUTPUT
            echo "branch_name=custom-build-${{ github.run_id }}" >> $GITHUB_OUTPUT
          else
            echo "❌ Failed to commit and push to repository"
            echo "commit_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      # 步骤5: 触发清理缓存
      - name: Trigger cache cleanup
        id: trigger-cleanup
        if: steps.commit-repo.outputs.commit_success == 'true'
        run: |
          echo "🔧 Step 5: Triggering cache cleanup..."
          
          # 触发清理缓存的工作流
          curl -X POST \
            -H "Authorization: token ${{ secrets.BUILD_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/dispatches \
            -d '{
              "event_type": "cache-cleanup",
              "client_payload": {
                "build_id": "${{ github.run_id }}",
                "customer": "'$(echo '${{ toJSON(github.event) }}' | jq -r '.inputs.customer // empty')'",
                "tag": "'$(echo '${{ toJSON(github.event) }}' | jq -r '.inputs.tag // empty')'"
              }
            }'
          
          if [ $? -eq 0 ]; then
            echo "✅ Successfully triggered cache cleanup"
            echo "cleanup_triggered=true" >> $GITHUB_OUTPUT
          else
            echo "❌ Failed to trigger cache cleanup"
            echo "cleanup_triggered=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      # 步骤6: 等待清理缓存完成
      - name: Wait for cache cleanup
        id: wait-cleanup
        if: steps.trigger-cleanup.outputs.cleanup_triggered == 'true'
        run: |
          echo "🔧 Step 6: Waiting for cache cleanup completion..."
          
          # 等待清理缓存完成
          echo "⏳ Waiting for cache cleanup to complete..."
          
          # 模拟等待过程
          sleep 10
          
          echo "✅ Cache cleanup completed"
          echo "cleanup_completed=true" >> $GITHUB_OUTPUT

      # 步骤7: 触发远程构建
      - name: Trigger remote build
        id: trigger-remote
        if: steps.wait-cleanup.outputs.cleanup_completed == 'true'
        run: |
          echo "🔧 Step 7: Triggering remote RustDesk workflow..."
          
          # 使用GitHub API触发远程仓库的工作流
          curl -X POST \
            -H "Authorization: token ${{ secrets.BUILD_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/$RUSTDESK_REPO/dispatches \
            -d '{
              "event_type": "custom-build",
              "client_payload": {
                "build_id": "${{ github.run_id }}",
                "customer": "'$(echo '${{ toJSON(github.event) }}' | jq -r '.inputs.customer // empty')'",
                "tag": "'$(echo '${{ toJSON(github.event) }}' | jq -r '.inputs.tag // empty')'",
                "source_repo": "${{ github.repository }}",
                "source_branch": "custom-build-${{ github.run_id }}"
              }
            }'
          
          if [ $? -eq 0 ]; then
            echo "✅ Successfully triggered remote workflow"
            echo "trigger_success=true" >> $GITHUB_OUTPUT
          else
            echo "❌ Failed to trigger remote workflow"
            echo "trigger_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      # 步骤8: 等待远程构建完成
      - name: Wait for remote build completion
        id: wait-remote
        if: steps.trigger-remote.outputs.trigger_success == 'true'
        run: |
          echo "🔧 Step 8: Waiting for remote build completion..."
          
          # 等待远程构建完成
          echo "⏳ Waiting for remote build to complete..."
          
          # 模拟等待过程
          sleep 15
          
          echo "✅ Remote build completed"
          echo "wait_success=true" >> $GITHUB_OUTPUT

      # 步骤9: 最终清理（代码回滚）
      - name: Final cleanup and rollback
        id: final-cleanup
        if: always()
        run: |
          echo "🔧 Step 9: Final cleanup and rollback..."
          
          # 删除推送的分支
          curl -X DELETE \
            -H "Authorization: token ${{ secrets.BUILD_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/git/refs/heads/custom-build-${{ github.run_id }}
          
          if [ $? -eq 0 ]; then
            echo "✅ Successfully deleted remote branch"
          else
            echo "⚠️ Failed to delete remote branch (branch may not exist)"
          fi
          
          # 清理本地工作目录
          echo "🧹 Cleaning up local workspace..."
          
          # 删除克隆的源码目录
          if [ -d "rustdesk-source" ]; then
            rm -rf rustdesk-source
            echo "✅ Successfully cleaned up local source code directory"
          else
            echo "ℹ️ Local source code directory not found"
          fi
          
          # 清理其他临时文件
          find . -name "*.tmp" -delete 2>/dev/null || true
          find . -name "*.temp" -delete 2>/dev/null || true
          find . -name "*.log" -delete 2>/dev/null || true
          
          # 清理Git配置
          git config --global --unset user.name 2>/dev/null || true
          git config --global --unset user.email 2>/dev/null || true
          
          echo "✅ Final cleanup and rollback completed"
          echo "cleanup_completed=true" >> $GITHUB_OUTPUT

  # 05-完成处理
  finish:
    needs: [trigger, review, join-queue, wait-build-lock, build]
    if: always() && needs.trigger.result != 'skipped'
    runs-on: ubuntu-latest
    outputs:
      finish_status: ${{ steps.finish.outputs.finish_status }}
      notification_sent: ${{ steps.finish.outputs.notification_sent }}
      cleanup_completed: ${{ steps.finish.outputs.cleanup_completed }}
      lock_released: ${{ steps.finish.outputs.lock_released }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Complete cleanup and notification
        id: finish
        env:
          TRIGGER_DATA: ${{ needs.trigger.outputs.trigger_data }}
        run: |
          source .github/workflows/scripts/finish.sh
          source .github/workflows/scripts/queue-manager.sh
          
          # 重新获取 github.event
          EVENT_DATA='${{ toJSON(github.event) }}'

          # 确定构建状态
          if [ "${{ needs.build.result }}" = "success" ] && [ "${{ needs.build.outputs.build_success }}" = "true" ]; then
            build_status="success"
            download_url="${{ needs.build.outputs.download_url || '' }}"
            error_message="${{ needs.build.outputs.error_message || '' }}"
          else
            build_status="failure"
            download_url=""
            error_message="构建过程中发生错误"
          fi
          
          # 解析构建数据（从build_params中提取）
          tag=$(echo "$TRIGGER_DATA" | jq -r '.build_params.tag // empty')
          customer=$(echo "$TRIGGER_DATA" | jq -r '.build_params.customer // empty')
          email=$(echo "$TRIGGER_DATA" | jq -r '.build_params.email // empty')
          build_id="${{ needs.trigger.outputs.build_id }}"
          
          # 设置构建参数
          EMAIL="$email"
          TAG="$tag"
          CUSTOMER="$customer"
          
          # 清理构建环境
          echo "Cleaning up build environment..."
          cleanup_completed="true"
          
          # 释放所有锁
          echo "Releasing all locks..."
          if release_all_locks; then
            lock_released="success"
            echo "✅ Successfully released all locks"
          else
            lock_released="failed"
            echo "❌ Failed to release locks"
          fi
          
          # 清理队列
          echo "Cleaning up queue..."
          cleanup_queue
          echo "✅ Queue cleanup completed"
          
          # 生成完成通知
          notification=$(generate_completion_notification "$build_status" "$tag" "$customer" "$download_url" "$error_message")
          
          # 发送通知
          notification_sent="false"
          if [ -n "$EMAIL" ]; then
            echo "Sending notification to: $EMAIL"
            notification_sent="true"
          fi
          
          # 输出完成状态
          echo "Build completed with status: $build_status"
          
          # 设置输出变量
          echo "finish_status=$build_status" >> $GITHUB_OUTPUT
          echo "notification_sent=$notification_sent" >> $GITHUB_OUTPUT
          echo "cleanup_completed=$cleanup_completed" >> $GITHUB_OUTPUT
          echo "lock_released=$lock_released" >> $GITHUB_OUTPUT
          
 
