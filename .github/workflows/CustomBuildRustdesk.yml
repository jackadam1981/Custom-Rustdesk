name: Custom Rustdesk Build Workflow

on:
  # Issue è§¦å‘
  issues:
    types: [opened]
  
  # æ‰‹åŠ¨è§¦å‘
  workflow_dispatch:
    inputs:
      tag:
        description: 'æž„å»ºæ ‡ç­¾'
        required: true
        default: 'custom'
      customer:
        description: 'å®¢æˆ·åç§°'
        required: true
        default: 'test'
      customer_link:
        description: 'å®¢æˆ·é“¾æŽ¥'
        required: false
        default: ''
      slogan:
        description: 'æ ‡è¯­'
        required: false
        default: 'Custom Rustdesk'
      email:
        description: 'é‚®ç®±åœ°å€'
        required: true
        default: 'admin@example.com'
      super_password:
        description: 'è¶…çº§å¯†ç '
        required: true
        default: 'password123'
      rendezvous_server:
        description: 'RendezvousæœåŠ¡åœ°å€'
        required: true
        default: '192.168.1.100'
      rs_pub_key:
        description: 'RSå…¬é’¥'
        required: false
        default: ''
      api_server:
        description: 'APIæœåŠ¡åœ°å€'
        required: true
        default: 'http://192.168.1.100:21114'
      enable_debug:
        description: 'å¯ç”¨è°ƒè¯•æ¨¡å¼ï¼ˆä»…æ‰‹åŠ¨è§¦å‘æ—¶æœ‰æ•ˆï¼‰'
        required: false
        default: true
        type: boolean

permissions:
  issues: write
  contents: read
  actions: read

# ç»Ÿä¸€çŽ¯å¢ƒå˜é‡é…ç½®
env:
  GITHUB_TOKEN: ${{ secrets.BUILD_TOKEN }}
  ENCRYPTION_KEY: ${{ secrets.ENCRYPTION_KEY }}
  QUEUE_ISSUE_NUMBER: '1'
  DEBUG_ENABLED: ${{ vars.DEBUG_ENABLED || 'false' }}
  # è¿œç¨‹ä»“åº“é…ç½® - å›ºå®šè®¾ç½®
  RUSTDESK_REPO: 'rustdesk/rustdesk'
  RUSTDESK_BRANCH: 'master'
  REMOTE_WORKFLOW_NAME: 'Build'
  # é»˜è®¤å€¼é…ç½®
  DEFAULT_TAG: ${{ secrets.DEFAULT_TAG }}
  DEFAULT_EMAIL: ${{ secrets.DEFAULT_EMAIL }}
  DEFAULT_CUSTOMER: ${{ secrets.DEFAULT_CUSTOMER }}
  DEFAULT_CUSTOMER_LINK: ${{ secrets.DEFAULT_CUSTOMER_LINK }}
  DEFAULT_SUPER_PASSWORD: ${{ secrets.DEFAULT_SUPER_PASSWORD }}
  DEFAULT_SLOGAN: ${{ secrets.DEFAULT_SLOGAN }}
  DEFAULT_RENDEZVOUS_SERVER: ${{ secrets.DEFAULT_RENDEZVOUS_SERVER }}
  DEFAULT_RS_PUB_KEY: ${{ secrets.DEFAULT_RS_PUB_KEY }}
  DEFAULT_API_SERVER: ${{ secrets.DEFAULT_API_SERVER }}

jobs:
  # 00-è§¦å‘å¤„ç† - æå–å’ŒéªŒè¯å‚æ•°
  trigger:
    runs-on: ubuntu-latest
    outputs:
      build_id: ${{ steps.trigger.outputs.build_id }}
      trigger_data: ${{ steps.trigger.outputs.trigger_data }}
      validation_passed: ${{ steps.trigger.outputs.validation_passed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Process trigger and validate parameters
        id: trigger
        run: |
          source .github/workflows/scripts/trigger.sh
          
          # ä½¿ç”¨çŽ¯å¢ƒå˜é‡ä¼ é€’äº‹ä»¶æ•°æ®
          export EVENT_DATA='${{ toJSON(github.event) }}'
          echo "DEBUG: EVENT_DATA = $EVENT_DATA"
          echo "DEBUG: github.event_name = ${{ github.event_name }}"
          echo "DEBUG: github.event.issue.number = ${{ github.event.issue.number }}"
          
          # æ ¹æ®è§¦å‘ç±»åž‹æå–å‚æ•°
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # æå–å‚æ•°å¹¶è®¾ç½®çŽ¯å¢ƒå˜é‡
            params=$(trigger_manager "extract-workflow-dispatch" "$EVENT_DATA")
            echo "DEBUG: workflow_dispatch params = $params"
            eval "$params"
            
            echo "DEBUG: After extract, TAG=$TAG, EMAIL=$EMAIL, CUSTOMER=$CUSTOMER"
            
            # å¤„ç†tagæ—¶é—´æˆ³
            final_tag=$(trigger_manager "process-tag" "$EVENT_DATA")
            echo "DEBUG: final_tag = $final_tag"
            
            # ç”Ÿæˆæœ€ç»ˆJSONæ•°æ®
            final_data=$(trigger_manager "generate-data" "$EVENT_DATA" "$final_tag")
            echo "DEBUG: final_data = $final_data"
            
            # éªŒè¯å‚æ•°
            validation_result=$(trigger_manager "validate-parameters" "$final_data")
            validation_exit_code=$?
            echo "DEBUG: validation_result = $validation_result, exit_code = $validation_exit_code"
            
            # è¾“å‡ºåˆ°GitHub Actions
            trigger_manager "output-to-github" "$final_data"
            echo "DEBUG: output-to-github completed"
          else
            # Issueè§¦å‘çš„æƒ…å†µ
            params=$(trigger_manager "extract-issue" "$EVENT_DATA")
            echo "DEBUG: issue params = $params"
            eval "$params"
            
            echo "DEBUG: After extract, TAG=$TAG, EMAIL=$EMAIL, CUSTOMER=$CUSTOMER"
            
            # å¤„ç†tagæ—¶é—´æˆ³
            final_tag=$(trigger_manager "process-tag" "$EVENT_DATA")
            echo "DEBUG: final_tag = $final_tag"
            
            # ç”Ÿæˆæœ€ç»ˆJSONæ•°æ®
            final_data=$(trigger_manager "generate-data" "$EVENT_DATA" "$final_tag")
            echo "DEBUG: final_data = $final_data"
            
            # éªŒè¯å‚æ•°
            validation_result=$(trigger_manager "validate-parameters" "$final_data")
            validation_exit_code=$?
            echo "DEBUG: validation_result = $validation_result, exit_code = $validation_exit_code"
            
            # è¾“å‡ºåˆ°GitHub Actions
            trigger_manager "output-to-github" "$final_data"
            echo "DEBUG: output-to-github completed"
          fi
          
          # è®¾ç½®éªŒè¯ç»“æžœ
          if [ $validation_exit_code -eq 0 ]; then
            echo "validation_passed=true" >> $GITHUB_OUTPUT
          else
            echo "validation_passed=false" >> $GITHUB_OUTPUT
          fi

  # 01-å®¡æ ¸éªŒè¯ - å¤„ç†éœ€è¦å®¡æ ¸çš„æƒ…å†µ
  review:
    needs: trigger
    if: needs.trigger.outputs.validation_passed == 'true'
    runs-on: ubuntu-latest
    outputs:
      review_passed: ${{ steps.review.outputs.review_passed }}
      review_reason: ${{ steps.review.outputs.review_reason }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Review and validate
        id: review
        shell: bash
        env:
          TRIGGER_DATA: ${{ needs.trigger.outputs.trigger_data }}
        run: |
          source .github/workflows/scripts/review.sh

          # é‡æ–°èŽ·å– github.event
          EVENT_DATA='${{ toJSON(github.event) }}'
          
          # éªŒè¯å‚æ•°
          validation_result=$(review_manager "validate" "$EVENT_DATA" "$TRIGGER_DATA" || true)
          validation_exit_code=$?
          
          if [ $validation_exit_code -ne 0 ]; then
            # å‚æ•°éªŒè¯å¤±è´¥ï¼Œå¤„ç†æ‹’ç»
            review_manager "handle-rejection" "$EVENT_DATA" "$TRIGGER_DATA" "$validation_result" || true
            echo "review_passed=false" >> $GITHUB_OUTPUT
            echo "review_reason=å‚æ•°éªŒè¯å¤±è´¥" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # æ£€æŸ¥æ˜¯å¦éœ€è¦å®¡æ ¸
          need_review=$(review_manager "need-review" "$EVENT_DATA" "$TRIGGER_DATA" || true)
          
          # å¦‚æžœæ˜¯issueè§¦å‘ï¼Œæ¸…ç†issueå†…å®¹
          if [ "${{ github.event_name }}" = "issues" ]; then
            source .github/workflows/scripts/trigger.sh
            
            # ä»ŽTRIGGER_DATAä¸­æå–å‚æ•°ç”¨äºŽæ¸…ç†
            final_tag_param=$(echo "$TRIGGER_DATA" | jq -r '.build_params.tag // empty')
            original_tag_param=$(echo "$TRIGGER_DATA" | jq -r '.build_params.original_tag // empty')
            customer_param=$(echo "$TRIGGER_DATA" | jq -r '.build_params.customer // empty')
            slogan_param=$(echo "$TRIGGER_DATA" | jq -r '.build_params.slogan // empty')
            
            cleaned_body=$(trigger_manager "clean-issue" "$final_tag_param" "$original_tag_param" "$customer_param" "$slogan_param")
            issue_number="${{ github.event.issue.number }}"
            trigger_manager "update-issue" "$issue_number" "$cleaned_body"
          fi
          
          if [ "$need_review" = "true" ]; then
            # éœ€è¦å®¡æ ¸ï¼Œåœ¨issueä¸­å›žå¤éœ€è¦å®¡æ ¸çš„ä¿¡æ¯
            if [ "${{ github.event_name }}" = "issues" ]; then
              source .github/workflows/scripts/issue-templates.sh
              review_comment=$(generate_review_required_template "${{ github.run_id }}" "${{ github.event.issue.number }}" "$TRIGGER_DATA")
              source .github/workflows/scripts/issue-manager.sh
              add_issue_comment "${{ github.event.issue.number }}" "$review_comment" || true
            fi
            
            # å¤„ç†å®¡æ ¸æµç¨‹
            review_result=$(review_manager "handle-review" "$EVENT_DATA" "$TRIGGER_DATA" || true)
            review_exit_code=$?
            
            if [ $review_exit_code -eq 0 ]; then
              echo "review_passed=true" >> $GITHUB_OUTPUT
              echo "review_reason=" >> $GITHUB_OUTPUT
            elif [ $review_exit_code -eq 1 ]; then
              echo "review_passed=false" >> $GITHUB_OUTPUT
              echo "review_reason=å®¡æ ¸è¢«æ‹’ç»" >> $GITHUB_OUTPUT
            elif [ $review_exit_code -eq 2 ]; then
              echo "review_passed=false" >> $GITHUB_OUTPUT
              echo "review_reason=å®¡æ ¸è¶…æ—¶" >> $GITHUB_OUTPUT
            fi
          else
            # ä¸éœ€è¦å®¡æ ¸ï¼Œç›´æŽ¥é€šè¿‡
            echo "review_passed=true" >> $GITHUB_OUTPUT
            echo "review_reason=" >> $GITHUB_OUTPUT
          fi
          
          # è¾“å‡ºæ•°æ®ï¼ˆä¼ é€’å®¡æ ¸ç»“æžœï¼‰
          review_manager "output-data" "$EVENT_DATA" "$TRIGGER_DATA" "$([ "$need_review" = "true" ] && [ $review_exit_code -eq 1 ] && echo "true" || echo "false")" "$([ "$need_review" = "true" ] && [ $review_exit_code -eq 2 ] && echo "true" || echo "false")" || true

  # 02-åŠ å…¥é˜Ÿåˆ—
  join-queue:
    needs: [trigger, review]
    if: needs.trigger.outputs.validation_passed == 'true' && needs.review.outputs.review_passed == 'true'
    runs-on: ubuntu-latest
    outputs:
      join_success: ${{ steps.join-queue.outputs.join_success }}
      queue_position: ${{ steps.join-queue.outputs.queue_position }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Join build queue
        id: join-queue
        env:
          TRIGGER_DATA: ${{ needs.trigger.outputs.trigger_data }}
          DEBUG_ENABLED: true
        run: |
          source .github/workflows/scripts/queue-manager.sh

          # åŠ å…¥é˜Ÿåˆ—
          echo "Joining build queue..."
          echo "DEBUG: TRIGGER_DATA = $TRIGGER_DATA"
          echo "DEBUG: GITHUB_RUN_ID = $GITHUB_RUN_ID"
          
          join_result=$(queue_manager 'queue_lock' 'join' "$TRIGGER_DATA")
          join_exit_code=$?
          
          # æ£€æŸ¥åŠ å…¥ç»“æžœ
          if [ $join_exit_code -eq 0 ]; then
            echo "âœ… Successfully joined queue"
            echo "join_success=true" >> $GITHUB_OUTPUT
            
            # ä»Žjoin_resultä¸­æå–é˜Ÿåˆ—ä½ç½®
            queue_position=$(echo "$join_result" | jq -r '.queue_position // 1')
            echo "queue_position=$queue_position" >> $GITHUB_OUTPUT
          else
            echo "âŒ Failed to join queue"
            echo "join_success=false" >> $GITHUB_OUTPUT
            echo "queue_position=-1" >> $GITHUB_OUTPUT
          fi

  # 03-ç­‰å¾…æž„å»ºé”
  wait-build-lock:
    needs: [trigger, review, join-queue]
    if: needs.trigger.outputs.validation_passed == 'true' && needs.review.outputs.review_passed == 'true' && needs.join-queue.outputs.join_success == 'true'
    runs-on: ubuntu-latest
    outputs:
      build_lock_acquired: ${{ steps.wait-build-lock.outputs.build_lock_acquired }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Wait for build lock
        id: wait-build-lock
        env:
          DEBUG_ENABLED: true
        run: |
          source .github/workflows/scripts/queue-manager.sh

          # èŽ·å–æž„å»ºé”
          echo "Acquiring build lock..."
          echo "DEBUG: GITHUB_RUN_ID = $GITHUB_RUN_ID"
          
          if queue_manager 'build_lock' 'acquire'; then
            echo "âœ… Successfully acquired build lock"
            echo "build_lock_acquired=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ Failed to acquire build lock"
            echo "build_lock_acquired=false" >> $GITHUB_OUTPUT
          fi

  # 04-æ‰§è¡Œæž„å»º
  build:
    needs: [trigger, review, join-queue, wait-build-lock]
    if: needs.trigger.outputs.validation_passed == 'true' && needs.review.outputs.review_passed == 'true' && needs.join-queue.outputs.join_success == 'true' && needs.wait-build-lock.outputs.build_lock_acquired == 'true'
    runs-on: ubuntu-latest
    outputs:
      build_success: ${{ steps.build.outputs.build_success }}
      download_url: ${{ steps.build.outputs.download_url }}
      error_message: ${{ steps.build.outputs.error_message }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Execute build process
        id: build
        env:
          TRIGGER_DATA: ${{ needs.trigger.outputs.trigger_data }}
        run: |
          source .github/workflows/scripts/build.sh
          
          # é‡æ–°èŽ·å– github.event
          EVENT_DATA='${{ toJSON(github.event) }}'

          # æå–æ•°æ®
          extracted_data=$(build_manager "extract-data" "$TRIGGER_DATA")
          extract_exit_code=$?
          
          if [ $extract_exit_code -ne 0 ]; then
            echo "âŒ Failed to extract build data"
            echo "build_success=false" >> $GITHUB_OUTPUT
            echo "download_url=" >> $GITHUB_OUTPUT
            echo "error_message=Failed to extract build parameters" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # å¤„ç†æž„å»ºæ•°æ®
          processed_data=$(build_manager "process-data" "$extracted_data")
          process_exit_code=$?
          
          if [ $process_exit_code -ne 0 ]; then
            echo "âŒ Failed to process build data"
            echo "build_success=false" >> $GITHUB_OUTPUT
            echo "download_url=" >> $GITHUB_OUTPUT
            echo "error_message=Failed to process build data" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # è¾“å‡ºæž„å»ºæ•°æ®
          build_manager "output-data" "$processed_data"

      # æ­¥éª¤1: å…‹éš†è¿œç¨‹æºç 
      - name: Clone RustDesk source code
        id: clone-source
        run: |
          echo "ðŸ”§ Step 1: Cloning RustDesk source code..."
          
          # è®¾ç½®Gité…ç½®
          git config --global user.name "Custom Build Bot"
          git config --global user.email "build@custom-rustdesk.com"
          
          # å…‹éš†è¿œç¨‹ä»“åº“
          git clone --depth 1 --branch $RUSTDESK_BRANCH https://github.com/$RUSTDESK_REPO.git rustdesk-source
          
          if [ $? -eq 0 ]; then
            echo "âœ… Successfully cloned RustDesk source code"
            echo "clone_success=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ Failed to clone RustDesk source code"
            echo "clone_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      # æ­¥éª¤2: ä¿®æ”¹æºç 
      - name: Modify source code
        id: modify-source
        if: steps.clone-source.outputs.clone_success == 'true'
        env:
          BUILD_TAG: ${{ env.BUILD_TAG }}
          BUILD_CUSTOMER: ${{ env.BUILD_CUSTOMER }}
          BUILD_SLOGAN: ${{ env.BUILD_SLOGAN }}
          BUILD_SUPER_PASSWORD: ${{ env.BUILD_SUPER_PASSWORD }}
          BUILD_RENDEZVOUS_SERVER: ${{ env.BUILD_RENDEZVOUS_SERVER }}
          BUILD_API_SERVER: ${{ env.BUILD_API_SERVER }}
        run: |
          echo "ðŸ”§ Step 2: Modifying source code with custom parameters..."
          
          cd rustdesk-source
          
          # å ä½ï¼šä¿®æ”¹æºç ä¸­çš„ç›¸å…³å‚æ•°
          # TODO: å®žçŽ°å…·ä½“çš„æºç ä¿®æ”¹é€»è¾‘
          echo "ðŸ“ Modifying customer name: $BUILD_CUSTOMER"
          echo "ðŸ“ Modifying slogan: $BUILD_SLOGAN"
          echo "ðŸ“ Modifying super password: $BUILD_SUPER_PASSWORD"
          echo "ðŸ“ Modifying rendezvous server: $BUILD_RENDEZVOUS_SERVER"
          echo "ðŸ“ Modifying API server: $BUILD_API_SERVER"
          
          # å¿«é€Ÿæ¨¡æ‹Ÿä¿®æ”¹è¿‡ç¨‹ï¼ˆå®žé™…æž„å»ºåœ¨build.shä¸­ï¼‰
          sleep 2
          
          echo "âœ… Source code modification completed"
          echo "modify_success=true" >> $GITHUB_OUTPUT

      # æ­¥éª¤3: æŽ¨é€åˆ°æœ¬ä»“åº“
      - name: Push to current repository
        id: push-repo
        if: steps.modify-source.outputs.modify_success == 'true'
        run: |
          echo "ðŸ”§ Step 3: Pushing modified code to current repository..."
          
          cd rustdesk-source
          
          # æ·»åŠ è¿œç¨‹ä»“åº“
          git remote add custom-repo https://x-access-token:${{ secrets.BUILD_TOKEN }}@github.com/${{ github.repository }}.git
          
          # åˆ›å»ºæ–°åˆ†æ”¯
          git checkout -b custom-build-${{ github.run_id }}
          
          # æäº¤ä¿®æ”¹
          git add .
          git commit -m "Custom build for $BUILD_TAG - Customer: $BUILD_CUSTOMER"
          
          # æŽ¨é€åˆ°æœ¬ä»“åº“
          git push custom-repo custom-build-${{ github.run_id }}
          
          if [ $? -eq 0 ]; then
            echo "âœ… Successfully pushed to current repository"
            echo "push_success=true" >> $GITHUB_OUTPUT
            echo "branch_name=custom-build-${{ github.run_id }}" >> $GITHUB_OUTPUT
          else
            echo "âŒ Failed to push to current repository"
            echo "push_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      # æ­¥éª¤4: è§¦å‘è¿œç¨‹æºç çš„å·¥ä½œæµ
      - name: Trigger remote workflow
        id: trigger-remote
        if: steps.push-repo.outputs.push_success == 'true'
        run: |
          echo "ðŸ”§ Step 4: Triggering remote RustDesk workflow..."
          
          # ä½¿ç”¨GitHub APIè§¦å‘è¿œç¨‹ä»“åº“çš„å·¥ä½œæµ
          curl -X POST \
            -H "Authorization: token ${{ secrets.BUILD_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/$RUSTDESK_REPO/dispatches \
            -d '{
              "event_type": "custom-build",
              "client_payload": {
                "build_id": "${{ github.run_id }}",
                "customer": "$BUILD_CUSTOMER",
                "tag": "$BUILD_TAG",
                "source_repo": "${{ github.repository }}",
                "source_branch": "custom-build-${{ github.run_id }}"
              }
            }'
          
          if [ $? -eq 0 ]; then
            echo "âœ… Successfully triggered remote workflow"
            echo "trigger_success=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ Failed to trigger remote workflow"
            echo "trigger_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      # æ­¥éª¤5: ç­‰å¾…è¿œç¨‹æž„å»ºå®Œæˆ
      - name: Wait for remote build completion
        id: wait-remote
        if: steps.trigger-remote.outputs.trigger_success == 'true'
        run: |
          echo "ðŸ”§ Step 5: Waiting for remote build completion..."
          
          # å ä½ï¼šç­‰å¾…è¿œç¨‹æž„å»ºå®Œæˆ
          # TODO: å®žçŽ°å…·ä½“çš„ç­‰å¾…é€»è¾‘
          echo "â³ Waiting for remote build to complete..."
          
          # å¿«é€Ÿæ¨¡æ‹Ÿç­‰å¾…è¿‡ç¨‹ï¼ˆå®žé™…æž„å»ºåœ¨build.shä¸­ï¼‰
          sleep 5
          
          echo "âœ… Remote build completed"
          echo "wait_success=true" >> $GITHUB_OUTPUT

      # æ­¥éª¤6: å›žé€€ä»“åº“
      - name: Revert repository
        id: revert-repo
        if: steps.wait-remote.outputs.wait_success == 'true'
        run: |
          echo "ðŸ”§ Step 6: Reverting repository changes..."
          
          # åˆ é™¤æŽ¨é€çš„åˆ†æ”¯
          curl -X DELETE \
            -H "Authorization: token ${{ secrets.BUILD_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/git/refs/heads/custom-build-${{ github.run_id }}
          
          if [ $? -eq 0 ]; then
            echo "âœ… Successfully deleted remote branch"
          else
            echo "âš ï¸ Failed to delete remote branch (branch may not exist)"
          fi
          
          # æ¸…ç†æœ¬åœ°å·¥ä½œç›®å½•
          echo "ðŸ§¹ Cleaning up local workspace..."
          
          # åˆ é™¤å…‹éš†çš„æºç ç›®å½•
          if [ -d "rustdesk-source" ]; then
            rm -rf rustdesk-source
            echo "âœ… Successfully cleaned up local source code directory"
          else
            echo "â„¹ï¸ Local source code directory not found"
          fi
          
          # æ¸…ç†å…¶ä»–å¯èƒ½çš„ä¸´æ—¶æ–‡ä»¶
          find . -name "*.tmp" -delete 2>/dev/null || true
          find . -name "*.temp" -delete 2>/dev/null || true
          
          echo "âœ… Successfully reverted repository and cleaned up workspace"
          echo "revert_success=true" >> $GITHUB_OUTPUT

      # æ­¥éª¤7: æœ€ç»ˆæ¸…ç†ï¼ˆæ— è®ºæˆåŠŸè¿˜æ˜¯å¤±è´¥ï¼‰
      - name: Final cleanup
        id: final-cleanup
        if: always()
        run: |
          echo "ðŸ§¹ Final cleanup step..."
          
          # ç¡®ä¿æ¸…ç†æœ¬åœ°æºç ç›®å½•
          if [ -d "rustdesk-source" ]; then
            rm -rf rustdesk-source
            echo "âœ… Cleaned up rustdesk-source directory"
          fi
          
          # æ¸…ç†å…¶ä»–ä¸´æ—¶æ–‡ä»¶
          find . -name "*.tmp" -delete 2>/dev/null || true
          find . -name "*.temp" -delete 2>/dev/null || true
          find . -name "*.log" -delete 2>/dev/null || true
          
          # æ¸…ç†Gité…ç½®
          git config --global --unset user.name 2>/dev/null || true
          git config --global --unset user.email 2>/dev/null || true
          
          echo "âœ… Final cleanup completed"
          echo "cleanup_completed=true" >> $GITHUB_OUTPUT

  # 05-å®Œæˆå¤„ç†
  finish:
    needs: [trigger, review, join-queue, wait-build-lock, build]
    if: always() && needs.trigger.result != 'skipped'
    runs-on: ubuntu-latest
    outputs:
      finish_status: ${{ steps.finish.outputs.finish_status }}
      notification_sent: ${{ steps.finish.outputs.notification_sent }}
      cleanup_completed: ${{ steps.finish.outputs.cleanup_completed }}
      lock_released: ${{ steps.finish.outputs.lock_released }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Complete cleanup and notification
        id: finish
        env:
          TRIGGER_DATA: ${{ needs.trigger.outputs.trigger_data }}
        run: |
          source .github/workflows/scripts/finish.sh
          source .github/workflows/scripts/queue-manager.sh
          
          # é‡æ–°èŽ·å– github.event
          EVENT_DATA='${{ toJSON(github.event) }}'

          # ç¡®å®šæž„å»ºçŠ¶æ€
          if [ "${{ needs.build.result }}" = "success" ] && [ "${{ needs.build.outputs.build_success }}" = "true" ]; then
            build_status="success"
            download_url="${{ needs.build.outputs.download_url || '' }}"
            error_message="${{ needs.build.outputs.error_message || '' }}"
          else
            build_status="failure"
            download_url=""
            error_message="æž„å»ºè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯"
          fi
          
          # è§£æžæž„å»ºæ•°æ®ï¼ˆä»Žbuild_paramsä¸­æå–ï¼‰
          tag=$(echo "$TRIGGER_DATA" | jq -r '.build_params.tag // empty')
          customer=$(echo "$TRIGGER_DATA" | jq -r '.build_params.customer // empty')
          email=$(echo "$TRIGGER_DATA" | jq -r '.build_params.email // empty')
          build_id="${{ needs.trigger.outputs.build_id }}"
          
          # è®¾ç½®æž„å»ºå‚æ•°
              EMAIL="$email"
              TAG="$tag"
              CUSTOMER="$customer"
          
          # æ¸…ç†æž„å»ºçŽ¯å¢ƒ
          echo "Cleaning up build environment..."
            cleanup_completed="true"
          
          # é‡Šæ”¾æ‰€æœ‰é”
          echo "Releasing all locks..."
          if release_all_locks; then
            lock_released="success"
            echo "âœ… Successfully released all locks"
          else
            lock_released="failed"
            echo "âŒ Failed to release locks"
          fi
          
          # æ¸…ç†é˜Ÿåˆ—
          echo "Cleaning up queue..."
          cleanup_queue
          echo "âœ… Queue cleanup completed"
          
          # ç”Ÿæˆå®Œæˆé€šçŸ¥
          notification=$(generate_completion_notification "$build_status" "$tag" "$customer" "$download_url" "$error_message")
          
          # å‘é€é€šçŸ¥
          notification_sent="false"
          if [ -n "$EMAIL" ]; then
            echo "Sending notification to: $EMAIL"
            notification_sent="true"
          fi
          
          # è¾“å‡ºå®ŒæˆçŠ¶æ€
          echo "Build completed with status: $build_status"
          
          # è®¾ç½®è¾“å‡ºå˜é‡
          echo "finish_status=$build_status" >> $GITHUB_OUTPUT
          echo "notification_sent=$notification_sent" >> $GITHUB_OUTPUT
          echo "cleanup_completed=$cleanup_completed" >> $GITHUB_OUTPUT
          echo "lock_released=$lock_released" >> $GITHUB_OUTPUT
          
 
